\hypertarget{structure}{%
\section{Structure}\label{structure}}

\hypertarget{borrow-checking}{%
\subsection{Borrow-checking}\label{borrow-checking}}

\hypertarget{lexical-borrow-checking}{%
\subsubsection{Lexical borrow-checking}\label{lexical-borrow-checking}}

\hypertarget{non-lexical-borrow-checking}{%
\subsubsection{Non-lexical
borrow-checking}\label{non-lexical-borrow-checking}}

\hypertarget{polonius}{%
\subsubsection{Polonius}\label{polonius}}

\hypertarget{ir-comparison}{%
\subsection{IR comparison}\label{ir-comparison}}

\hypertarget{gccrs-borrow-checker-design}{%
\subsection{Gccrs borrow-checker
design}\label{gccrs-borrow-checker-design}}

\hypertarget{bir}{%
\subsubsection{BIR}\label{bir}}

\hypertarget{bir-building}{%
\subsubsection{BIR building}\label{bir-building}}

\hypertarget{tyty-generic-types}{%
\subsubsection{TyTy Generic types}\label{tyty-generic-types}}

\hypertarget{variance-analysys}{%
\paragraph{Variance analysys}\label{variance-analysys}}

\hypertarget{bir-fact-collection-and-checking}{%
\subsubsection{BIR fact collection and
checking}\label{bir-fact-collection-and-checking}}

Building a borrow-checker consists of two main parts. First, we need to
extract information about the program. We will call that information
\emph{facts}. (This follows the terminology used by Polonius
\href{}{link polonius book/facts}.) Second, we need to use those facts
to check the program.

To understand how facts are extracted in gccrs and rustc, we need to
understand how programs are represented in each compiler.

\hypertarget{gcc-vs-llvm}{%
\subsection{GCC vs LLVM}\label{gcc-vs-llvm}}

To understand the differences between gccrs and rustc, we must first
explore the differences of the compiler platforms they are built on.
Gccrs is build on top of GCC, while rustc is built on top of LLVM. We
will only focus on front-end and middle-end of each compiler platform,
since back-end is not relevant to borrow-checking.

The core of LLVM is a three-address code (3-AD) representation called
the LLVM intermediate representation (LLVM IR). This IR is the interface
between the front-end and the compiler platform (middle-end and
back-end). Three-address code represents the program as sequences of
statements (we call such sequence a \emph{basic block}). Connected by
control flow instructions, forming a control flow graph (CFG). The fact
that the LLVM IR is a 3-AD representation is very important to how the
program is represented inside rustc.

GCC, on the other hand, interfaces with the front-ends on a tree-like
representation called the GENERIC. This representation is based on the
AST of the C front end, but it can store information specific to each
front-end. This representation is then transformed into a GIMPLE
representation, which is a 3-AD representation. This transformation is
already done inside the compiler platform, not in the front-end. GENERIC
representation cannot contain information specific to each front-end
{[}\^{}2{]}(This is not entirely true. There are hacks that are used to
annotate GIMPLE statements with specific information using dummy
statements.). This approach allows the front-ends to be smaller and
pushing more works into the shared part.

\hypertarget{rustcs-representation}{%
\subsection{Rustc's representation}\label{rustcs-representation}}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ Foo(}\DataTypeTok{i32}\NormalTok{)}\OperatorTok{;}

\KeywordTok{fn}\NormalTok{ foo(x}\OperatorTok{:} \DataTypeTok{i32}\NormalTok{) }\OperatorTok{{-}\textgreater{}}\NormalTok{ Foo }\OperatorTok{\{}
\NormalTok{    Foo(x)}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{quote}
This very simple code will be used as an example throughout this
section.
\end{quote}

Rustc's parser produces an abstract syntax tree (AST) from a stream of
tokens. AST is a tree-based representation of the program, which closely
follows each token in the source code. At this stage, rustc performs
macro-expansion and a partial name resolution (macros and imports)
{[}https://rustc-dev-guide.rust-lang.org/macro-expansion.html,
https://rustc-dev-guide.rust-lang.org/name-resolution.html{]}. AST is
then transformed into a high-level intermediate representation (HIR).

\begin{verbatim}
Crate {
    attrs: [],
    items: [
        Item {
            attrs: [],
            span: example.rs:1:1: 1:17 (#0),
            vis: Visibility {
                kind: Inherited,
                span: no-location (#0),
                tokens: None,
            },
            ident: Foo#0,
            kind: Struct(
                Tuple(
                    [
                        FieldDef {
                            vis: Visibility {
                                kind: Inherited,
                                span: example.rs:1:12: 1:12 (#0),
                                tokens: None,
                            },
                            ident: None,
                            ty: Ty {
                                kind: Path(
                                    None,
                                    Path {
                                        segments: [
                                            PathSegment {
                                                ident: i32#0,
                                                args: None,
                                            },
                                        ],
                                        tokens: None,
                                    },
                                ),
                                tokens: None,
                            },
                            is_placeholder: false,
                        },
                    ],
                ),
                Generics {
                    params: [],
                    where_clause: WhereClause {
                        has_where_token: false,
                        predicates: [],
                    },
                },
            ),
            tokens: None,
        },
        Item {
            vis: Visibility {
                kind: Inherited,
                tokens: None,
            },
            ident: foo#0,
            kind: Fn(
                Fn {
                    defaultness: Final,
                    generics: Generics {
                        params: [],
                        where_clause: WhereClause {
                            has_where_token: false,
                            predicates: [],
                        },
                    },
                    sig: FnSig {
                        header: FnHeader {
                            unsafety: No,
                            asyncness: No,
                            constness: No,
                            ext: None,
                        },
                        decl: FnDecl {
                            inputs: [
                                Param {
                                    attrs: [],
                                    ty: Ty {
                                        kind: Path(
                                            None,
                                            Path {
                                                segments: [
                                                    PathSegment {
                                                        ident: i32#0,
                                                        id: NodeId(4294967040),
                                                        args: None,
                                                    },
                                                ],
                                                tokens: None,
                                            },
                                        ),
                                        tokens: None,
                                    },
                                    pat: Pat {
                                        kind: Ident(
                                            BindingAnnotation(
                                                No,
                                                Not,
                                            ),
                                            x#0,
                                            None,
                                        ),
                                        tokens: None,
                                    },
                                    is_placeholder: false,
                                },
                            ],
                            output: Ty(
                                Ty {
                                    id: NodeId(4294967040),
                                    kind: Path(
                                        None,
                                        Path {
                                            segments: [
                                                PathSegment {
                                                    ident: Foo#0,
                                                    id: NodeId(4294967040),
                                                    args: None,
                                                },
                                            ],
                                            tokens: None,
                                        },
                                    ),
                                    tokens: None,
                                },
                            ),
                        },
                    },
                    body: Some(
                        Block {
                            stmts: [
                                Stmt {
                                    kind: Expr(
                                        Expr {
                                            kind: Call(
                                                Expr {
                                                    kind: Path(
                                                        None,
                                                        Path {
                                                            segments: [
                                                                PathSegment {
                                                                    ident: Foo#0,
                                                                    id: NodeId(4294967040),
                                                                    args: None,
                                                                },
                                                            ],
                                                            tokens: None,
                                                        },
                                                    ),
                                                    tokens: None,
                                                },
                                                [
                                                    Expr {
                                                        kind: Path(
                                                            None,
                                                            Path {
                                                                segments: [
                                                                    PathSegment {
                                                                        ident: x#0,
                                                                        args: None,
                                                                    },
                                                                ],
                                                                tokens: None,
                                                            },
                                                        ),
                                                        tokens: None,
                                                    },
                                                ],
                                            ),
                                            tokens: None,
                                        },
                                    ),
                                },
                            ],
                            rules: Default,
                            tokens: None,
                            could_be_bare_literal: false,
                        },
                    ),
                },
            ),
            tokens: None,
        },
    ],
    is_placeholder: false,
}
\end{verbatim}

\begin{quote}
This is a textual representation of the abstract syntax tree (AST) of
the example program. For brevity, since the actual AST is very large, we
omit \texttt{id}, \texttt{span} (location within source code) and empty
\texttt{attrs} fields, which are present on every field.
\end{quote}

HIR is the main representation used for most rustc operations
{[}https://rustc-dev-guide.rust-lang.org/hir.html{]}. It combines a
desuggared version of the AST (for example, all loops are transformed to
a single infinite loop construct (Rust \texttt{loop} keyword)) with
additional tables and maps for quick access to information.
Typechecking, which includes both checking the type correctness of the
program as well as type inference, generic type substitution and most
other type operations, are performed on HIR.
{[}https://rustc-dev-guide.rust-lang.org/type-checking.html{]} The HIR
representaion can contain many placeholders and ``optional'' fields that
are resolved dusing the HIR analysis. To simplify further processing,
parts of HIR that correspond to executable code (e.g.~not type
definitions) are transformed to THIR (Typed High-Level Intermediate
Representation) where all the missing informaion (mainly types) must be
resolved. The reader can think about HIR and THIR in terms of the
builder pattern {[}https://en.wikipedia.org/wiki/Builder\_pattern{]},
where HIR provides flexible interface for modification and THIR the
final immutable representation. This does not only involve the data
explicitly stored in HIR, but also parts of the program, that are
implied from the type system. Operator overloading, automatic references
and dereferences, etc. are all resolved at this stage. One more notable
difference is that expression and statements (and match arms) are all
stored in a list and refer to each other using indices, instead of
pointers. This provides a more compact representation. The final rustc
IR that is lowered directly to LLVM IR is the MIR (Mid-level
Intermediate Representation). We will pay extra attention to MIR,
because it is the main representation used by the borrow-checker. MIR is
a three-address code representation, similar to LLVM IR but with
specific rustc constructs. It consists of basic blocks, which are
sequences of statements connected by control flow instructions. The
statements operate on places and rvalues. A place (often called lvalue
in other languages) is an abstract representation of a memory location.
It is either a local variable, a field, index or dereference of another
place.

For further details, see the \href{}{Source Code Representation} chapter
of the rustc developer guide.

\hypertarget{rust-gcc-borrow-checker-design}{%
\section{Rust GCC Borrow-checker
Design}\label{rust-gcc-borrow-checker-design}}

\begin{quote}
This section discusses the intermediate representation in gccrs. Since
gccrs is a second implementation of the Rust compiler, it is heavily
inspired by rustc. Therefore this section will assume familiarity with
rustc's intermediate representations, described in the previous section.
We will focus on similarities and differences between rustc and gccrs,
rather than describing the gccrs intermediate representation in detail.
\end{quote}

The Rust GCC borrow-checker is designed to be as similar to the
\texttt{rustc} borrow-checker as possible withing the constraints of the
Rust GCC IR. This allows us to leverage the existing knowledge about
borrow-checking in Rust. The differences between the IR and the
challenges they pose are discussed in the previous chapter. The main
decision of the Rust GCC borrow-checker is to reuse the dataflow
analysis engine from rustc. The interface between the analysis engine
and the compiler consist of passing a set of facts to the analysis
engine.

Ever since the introduction of NLL in rustc, the analysis is
control-flow sensitive. This requires us to collect the required facts
from a control-flow graph based IR which still contains rust specific
information.

We need to distinguish between pointers (in unsafe Rust) and references.
Pointer is not subject to borrow-checking, but references are.
Furthermore, we need to distinguish between mutable and immutable
references, since they have different rules, essential for
borrow-checking {[}\^{}{]}(The key rule of borrowchecking is the for a
single borrowed variable, there can only be a single mutable borrow, or
only immutable borrows valid at each point of the CFG.). Each type has
to carry information about lifetimes it contains and their variances.
For explicit user type annotation, we need to store the explicit
lifetime parameters.

The only IR in GCC what contains the CFG information is GIMPLE; however,
under normal circumstances GIMPLE is supposed to be language agnostic.
It is possible to annotate the GIMPLE statements with language specific
information, using special statements {[}quote Jan Hubicka
consulations{]}, however it is very complicated.

Initially, we have attempted to collect the information from HIR and
compute and approximate CFG as we go. This can work nicely for simple
language constructs, that are local, but its get very compicated for
more complex constructs like patterns, loops with breaks and continues,
etc. Further more, it was not clear, how to handle panics and unwinding.
An option to ease such problems was to radically desuggar the HIR to
only basic constructs. An advantage of this approach would be that it
would leverage the code already existing in the code generator, possibly
making the code generation easier. The most extreme case would be to add
rustc's MIR to gccrs. This approached as some advantages and many
problems. The main advange for borrow-checking is that the process of
lowering HIR to MIR would be covered by the current testsuite. Another
advantage, if full compatibility with rustc's MIR is achieved, is that
many MIR based tools (like MIRI) could be used with gccrs. Also the
borrow-checking itself would be very similar to rustc's borrow-checking.
The main problem with this approach is that it would require a large
portion of gccrs to be reimplemented, delaying the project by a
considerable amount of time. Should such an approach be taken, any
effort on borrow-checking would be delayed until the MIR is implemented.
It was decided by the maintainers that such an approach is not feasible
and that gccrs will not use MIR in any forseable future. The effort to
lift the HIR simplification done in the code generator to a HIR-to-HIR
simplification pass was also abandoned, due to high reliace of such
passes on the GENERIC API. After further discussion with the
maintainers, it was decided that the best apporach is to duplicate the
work and possibly unify it later. After Arthur Cohen suggesting to keep
the things simple, I have decided to experiment with another apporoach.
To build a extremply simplified MIR-like IR, that keeps only the bare
minimum of information needed for borrow-checking. Given unexpected
productivity of this approach, it was decided to go on with it. This IR,
later called the borrow-checker IR (BIR), only focuses on flow of data
and it ignores the actual operations on the data. The main disadvantage
of this approach is that it creates a dead branch of the compilation
pipeline, that is not used for code generation and therefore it is not
covered by the existing testsuite. To overcome this difficulty, the BIR
and it's textual representatio (dump) is designed to be as similar to
rustc's MIR as possible. This allows us to check the generated BIR
againts the MIR generated by rustc, at least for simple programs.

\hypertarget{bir-dump-example}{%
\subsection{BIR Dump Example}\label{bir-dump-example}}

An example program calculating the i-th fibonacci number:

\begin{Shaded}
\begin{Highlighting}[]

\KeywordTok{fn}\NormalTok{ fib(i}\OperatorTok{:} \DataTypeTok{usize}\NormalTok{) }\OperatorTok{{-}\textgreater{}} \DataTypeTok{i32} \OperatorTok{\{}
    \ControlFlowTok{if}\NormalTok{ i }\OperatorTok{==} \DecValTok{0} \OperatorTok{||}\NormalTok{ i }\OperatorTok{==} \DecValTok{1} \OperatorTok{\{}
        \DecValTok{1}
    \OperatorTok{\}} \ControlFlowTok{else} \OperatorTok{\{}
\NormalTok{        fib(i }\OperatorTok{{-}} \DecValTok{1}\NormalTok{) }\OperatorTok{+}\NormalTok{ fib(i }\OperatorTok{{-}} \DecValTok{2}\NormalTok{)}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Here is an example of BIR dump (note: this needs to be updated
regularly):

\begin{verbatim}
fn fib(_1: usize) -> i32 {
    let _0: i32;
    let _2: i32;
    let _3: bool;
    let _4: bool;
    let _5: bool;
    let _6: usize;
    let _7: i32;
    let _8: usize;
    let _9: i32;
    let _10: i32;

    bb0: {
        _4 = Operator(_1, const usize);
        switchInt(_4) -> [bb1, bb2];
    }

    bb1: {
        _3 = const bool;
        goto -> bb3;
    }

    bb2: {
        _5 = Operator(_1, const usize);
        _3 = _5;
        goto -> bb3;
    }

    bb3: {
        switchInt(_3) -> [bb4, bb7];
    }

    bb4: {
        _2 = const i32;
        goto -> bb8;
    }

    bb5: {
        _6 = Operator(_1, const usize);
        _7 = Call(fib)(_6, ) -> [bb6];
    }

    bb6: {
        _8 = Operator(_1, const usize);
        _9 = Call(fib)(_8, ) -> [bb7];
    }

    bb7: {
        _10 = Operator(_7, _9);
        _2 = _10;
        goto -> bb8;
    }

    bb8: {
        _0 = _2;
        return;
    }
}

\end{verbatim}

The dump consists of:

\begin{itemize}
\tightlist
\item
  A function header with arguments:
  \texttt{fn\ fib(\_1:\ usize)\ -\textgreater{}\ i32\ \{\ ...\ \}}.
\item
  Declaration of locals: \texttt{let\ \_0:\ i32;}, where \texttt{\_0} is
  the return value (even if it is of the unit type). Arguments are not
  listed here, they are listed in the function header.
\item
  A list of basic blocks: \texttt{bb0:\ \{\ ...\ \}}. The basic block
  name is the \texttt{bb} prefix followed by a number.
\item
  Each basic block consists of a list of BIR statements. Instruction can
  be either assigned to a local (place) or be a statement. Instructions
  take locals (places) as arguments.
\item
  Each basic block is terminated with a control flow instruction
  followed by a list of destinations:

  \begin{itemize}
  \tightlist
  \item
    \texttt{goto\ -\textgreater{}\ bb3;} - a goto instruction with a
    single destination.
  \item
    \texttt{switchInt(\_3)\ -\textgreater{}\ {[}bb4,\ bb7{]};} - a
    switch instruction with multiple destinations.
  \item
    \texttt{return;} - a return instruction with no destinations.
  \item
    \texttt{Call(fib)(\_6,\ )\ -\textgreater{}\ {[}bb6{]};} - a call
    instruction with a single destination. This section is prepared for
    panic handling.
  \end{itemize}
\end{itemize}

\hypertarget{bir-structure}{%
\subsection{BIR Structure}\label{bir-structure}}

BIR structure is defined in
\texttt{gcc/rust/checks/errors/borrowck/rust-bir.h}. It is heavily
inspired by rustc's MIR. The main difference is that BIR drastically
reduces the amount of information carried to only borrow-checking
relevant information.

As borrow-checking is performed on each function independently, BIR
represents a single function (\texttt{struct\ Function}). A
\texttt{Function} consists of a list of basic blocks, list of arguments
(for dump only) and place database, which keeps track of locals.

\hypertarget{basic-blocks}{%
\subsubsection{Basic Blocks}\label{basic-blocks}}

A basic block is identified by its index in the function's basic block
list. It contains a list of BIR statements and a list of successor basic
block indices in CFG.

\hypertarget{bir-statements}{%
\subsubsection{BIR Statements}\label{bir-statements}}

BIR statements are of three categories:

\begin{itemize}
\tightlist
\item
  An assignment of an expression to a local (place).
\item
  A control flow operation (switch, return).
\item
  A special statement (not executable), which carries additional
  information for borrow-checking (\texttt{StorageDead},
  \texttt{StorageLive}).
\end{itemize}

\hypertarget{expressions}{%
\paragraph{Expressions}\label{expressions}}

Expressions represent the executable parts of the rust code. Many
different Rust contracts are represented by a single expression, as only
data (and lifetime) flow needs to be tracked.

\begin{itemize}
\tightlist
\item
  \texttt{InitializerExpr} represents any kind of struct initialization.
  It can be either explicit (struct expression) or implicit (range
  expression, e.g.~\texttt{0..=5}).
\item
  \texttt{Operator\textless{}ARITY\textgreater{}} represents any kind of
  operation, except the following, where special information is needed
  either for borrow-checking or for better debugging.
\item
  \texttt{BorrowExpr} represents a borrow operation.
\item
  \texttt{AssignmentExpr} holds a place for an assignment statement
  (i.e., no operation is done on the place, it is just assigned).
\item
  \texttt{CallExpr} represents a function call.

  \begin{itemize}
  \tightlist
  \item
    For functions, the callable is represented by a constant place (see
    below). (E.i. all calls use the same constant place.)
  \item
    For closures and function pointers, the callable is represented by a
    (non-constant) place.
  \end{itemize}
\end{itemize}

\hypertarget{places}{%
\subsubsection{Places}\label{places}}

Places are defined in
\texttt{gcc/rust/checks/errors/borrowck/rust-bir-place.h}.

Places represent locals (variables), their field, and constants. They
are identified by their index (\texttt{PlaceId}) in the function's place
database. For better dump correspondence to MIR, constants use a
different index range.

Non-constant places are created according to Polonius path
\href{https://rust-lang.github.io/polonius/rules/atoms.html}{documentation}.
The following grammar describes possible path elements:

\begin{verbatim}
Path = Variable
     | Path "." Field // field access
     | Path "[" "]"   // index
     | "*" Path
\end{verbatim}

It is important to highlight that different fields are assigned to
different places; however, all indices are assigned to the same place.
Also, to match the output of rustc. In dump, paths contain at most one
dereference and are split otherwise. Same paths always result in the
same place.

Variables are identified by \texttt{AST} \texttt{NodeId}. Fields indexes
are taken from \texttt{TyTy} types.

Each place holds indices to its next relatives (in the path tree),
\texttt{TyTy} type, lifetime and information whether the type can be
copies or it needs to be moved. Not that unlike rustc, we copy any time
we can (for simplicity), while rustc prefers to move if possible (only a
single copy is held).

\hypertarget{generic-types}{%
\subsection{Generic types}\label{generic-types}}

Generic types impose some additional changes to the borrow-checker.
Generic types are generic over both types and lifetimes (and constants,
but that fact is not important for the borrow-checker). Types
substituted for type parameters can again be generic, creating a
structure known as higher-kinded lifetimes. The Rust language subtyping
rules allow types with different lifetimes to be coerced to each other.
This coercion has to follow the variance rules. The lifetimes can be
substituted in different contexts, leading a different

\hypertarget{rust-language-subtyping-rules}{%
\subsubsection{Rust Language Subtyping
Rules}\label{rust-language-subtyping-rules}}

The Rust language subtyping rules are defined in the
\href{https://doc.rust-lang.org/reference/subtyping.html}{the
reference}. Unlike other languages, which are based on the OOP
principles, Rust is very explicit about type conversions and therefore
leaving a very little space for subtyping. ``Subtyping is restricted to
two cases: variance with respect to lifetimes and between types with
higher ranked lifetimes.''.

\hypertarget{variance-analysis}{%
\subsubsection{Variance analysis}\label{variance-analysis}}

Variance analysis is a process of determining the variance of type and
lifetime generic parameters. '' F is covariant over T if T being a
subtype of U implies that F is a subtype of F (subtyping ``passes
through'') F is contravariant over T if T being a subtype of U implies
that F is a subtype of F F is invariant over T otherwise (no subtyping
relation can be derived) ''

Let us see what that means on example specific to lifetimes. For a
simple reference type \texttt{\&\textquotesingle{}a\ T}, the lifetime
parameter \texttt{\textquotesingle{}a} is covariant. That's means that
if we have a reference \texttt{\&\textquotesingle{}a\ T} and we can
coerce it to \texttt{\&\textquotesingle{}b\ T}, then
\texttt{\textquotesingle{}a} is a subtype of
\texttt{\textquotesingle{}b}. In other words, if we are storing a
reference to some memory, it is sound to assign it to a reference which
lives for a shorter period of time. That is, if it is save to
dereference a reference withing any point of period
\texttt{\textquotesingle{}a}, it is also safe to dereference it within
any point of period \texttt{\textquotesingle{}b}, which is a subset of
\texttt{\textquotesingle{}a} {[}\^{}{]}(Subset of CFG points.). The
situation is different when we pass a reference to a function as an
argument. In that case, the lifetime parameter is contravariant.

For function parameter, we need to ensure that the parameter lives as
long as the function needs it to. If we have a function pointer of type
\texttt{fn\ foo\textless{}\textquotesingle{}a\textgreater{}(x:\ \&\textquotesingle{}a\ T)},
we can coerce it to
\texttt{fn\ foo\textless{}\textquotesingle{}b\textgreater{}(x:\ \&\textquotesingle{}b\ T)},
where \texttt{\textquotesingle{}b} lives longer than
\texttt{\textquotesingle{}a}.

Let us look at that visually. In the following code, we have region
\texttt{\textquotesingle{}a} where it is save to reference the storage
of \texttt{x}, and region \texttt{\textquotesingle{}b} where it is save
to reference the storage of \texttt{y}. If a function will safely work
with a reference of lifetime \texttt{\textquotesingle{}b} it will also
safely work with a reference of lifetime \texttt{\textquotesingle{}a}.
Hence, we can ``pretend'' (understand: coerce) what
\texttt{fn(\&\textquotesingle{}b\ T)} is
\texttt{fn(\&\textquotesingle{}a\ T)}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let}\NormalTok{ x }\OperatorTok{=} \DecValTok{5}\OperatorTok{;}        \OperatorTok{|}\NormalTok{ region }\OtherTok{\textquotesingle{}a}
\OperatorTok{\{}                 \OperatorTok{|}
    \KeywordTok{let}\NormalTok{ y }\OperatorTok{=} \DecValTok{7}\OperatorTok{;}    \OperatorTok{|}             \OperatorTok{|}\NormalTok{ region }\OtherTok{\textquotesingle{}b}          
\OperatorTok{\}}                 \OperatorTok{|}
\end{Highlighting}
\end{Shaded}

The return type of a function is effectively an assignment to a local
variable (just accross function boundaries), and therefore is covariant.

The situation gets integresting, when there two rules re combined. Let
us have a function
\texttt{fn\ foo\textless{}\textquotesingle{}a\textgreater{}(x:\ \&\textquotesingle{}a\ T)\ -\textgreater{}\ \&\textquotesingle{}a\ T}.
The return type require the function to be covariant over
\texttt{\textquotesingle{}a}, while the parameter requires it to be
contravariant. This is called \emph{invariance}.

Rust uses `definition-site variance'. That means that the variance is
computed solely from the definition of the type, not from its usage.

Both rustc and gccrs variance analysis is based on Section 4 of the
paper ``Taming the Wildcards: Combining Definition- and Use-Site
Variance'' published in PLDI'11 and written by Altidor et al.~Notation
from the paper is followed in documentation of both compilers and in
this text. The paper primarily focuses on complex type variance, like in
the case of Java, but it introduces a simple calculus, which nicely
works with higher-kinded lifetimes.

The exact rules are best understood from the paper and from the code
itself. Therefore, here I will only give a simple overview. Lets assume
a generic structs.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ Foo}\OperatorTok{\textless{}}\OtherTok{\textquotesingle{}a}\OperatorTok{,} \OtherTok{\textquotesingle{}b}\OperatorTok{,}\NormalTok{ T}\OperatorTok{\textgreater{}} \OperatorTok{\{}
\NormalTok{    x}\OperatorTok{:} \OperatorTok{\&}\OtherTok{\textquotesingle{}a}\NormalTok{ T}\OperatorTok{,}
\NormalTok{    y}\OperatorTok{:}\NormalTok{ Bar}\OperatorTok{\textless{}}\NormalTok{T}\OperatorTok{\textgreater{},}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}
